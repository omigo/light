
// DO NOT EDIT THIS FILE!
// It is generated by `light` tool by source `{{.Source}}` at {{timestamp}}.

package {{.Name}}

import (
    "bytes"
    "encoding/json"
    "fmt"
    "github.com/arstd/log"
	"github.com/lib/pq"
    {{.ImportsExpr}}
)

{{- range .Interfaces}}
    {{- $itf := .}}

    type {{$itf.Name}}Impl struct{}

    {{- range .Methods}}
        func (*{{$itf.Name}}Impl) {{.Name}}({{.ParamsExpr}})({{.ResultsExpr}}) {
            {{$dbVar := (or "" $.DBVar)}}
            var (
                buf  bytes.Buffer
                args []interface{}
            )

            {{- block "fragments" .Fragments}}
                {{- range .}}
                    {{- if .Range}}
                        for {{.Index.Var}}, {{.Iterator.Var}} := range {{.Range.Var}} {
                            if {{.Index.Var}} != 0 {
                                buf.WriteString("{{.Seperator}}")
                            }
                    {{- else if .Cond}}
                        if {{.Cond}} {
                    {{- end}}
                            {{- if .Prepare}}
                                buf.WriteString(` {{.Prepare}}`)
                            {{- end}}

                            {{- range .Args}}
                                {{- if .DBType.Array}}
                                    args = append(args, pq.Array({{.Var}}))
                                {{- else if .Complex}}
                                    {{.Var2}}, _ := json.Marshal({{.Var}})
                                    args = append(args, {{.Var2}})
                                {{- else}}
                                    args = append(args, {{.Var}})
                                {{- end}}
                            {{- end}}

                            {{- template "fragments" .Fragments}}

                    {{- if .Range}}
                        }
                    {{- else if .Cond}}
                        }
                    {{- end}}

                {{- end}}{{/* end range fragments */}}
            {{- end}}{{/* end fragments block */}}

            ph := make([]interface{}, len(args))
            for i := range args {
                ph[i] = fmt.Sprintf("$%d", i+1)
            }
            query := fmt.Sprintf(buf.String(), ph...)

            {{- if ne .Kind "page"}}
                log.Debug(query)
                log.Debug(args...)
            {{- end}}

            {{- if or (eq .Kind "batch") (eq .Kind "update") (eq .Kind "delete")}}
                res, err := {{$dbVar}}.Exec(query, args...)
                if err != nil {
                    log.Error(query)
                    log.Error(args...)
                    log.Error(err)
                }
                return res.RowsAffected()
            {{- /* end batch method */}}

            {{- else if or (eq .Kind "get") (eq .Kind "insert")}}
                {{- if eq .Kind "get"}}
                    {{.Return.Var}} = {{.Return.MakeExpr}}
                {{- end}}
                dest := make([]interface{}, {{len .Returnings}})
                {{- $Return := .Return}}
                {{- range $i, $r := .Returnings}}
                    {{- if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                        var {{$Return.Var}}{{$r.Var2}} pq.NullTime
                        dest[{{$i}}] = &{{$Return.Var}}{{$r.Var2}}
                    {{- else if .DBType.Array}}
                        dest[{{$i}}] = pq.Array(&{{$Return.Var}}.{{$r.Var}})
                    {{- else if .Complex}}
                        var {{$Return.Var}}{{.Var2}} []byte
                        dest[{{$i}}] = &{{$Return.Var}}{{$r.Var2}}
                    {{- else}}
                        dest[{{$i}}] = &{{$Return.Var}}.{{$r.Var}}
                    {{- end}}
                {{- end}}
                err = db.QueryRow(query, args...).Scan(dest...)
                if err != nil {
            		log.Error(err)
            		log.Error(query)
            		log.Error(args...)
                    return
            	}
                {{- range $i, $r := .Returnings}}
                    {{- if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                        {{$Return.Var}}.{{$r.Var}} = {{$Return.Var}}{{$r.Var2}}.Time
                    {{- else if .DBType.Array}}
                    {{- else if .Complex}}
                        {{$Return.Var}}.{{$r.Var}} = {{$r.MakeExpr}}
                        json.Unmarshal({{$Return.Var}}{{.Var2}}, {{$r.VarPointerExpr}}{{$Return.Var}}.{{$r.Var}})
                    {{- end}}
                {{- end}}
                return
            {{- /* end batch method */}}

            {{- else if eq .Kind "list"}}
                var rows *sql.Rows
                rows, err = db.Query(query, args...)
                if err != nil {
                    log.Error(err)
                    log.Error(query)
                    log.Error(args...)
                    return
                }
                defer rows.Close()

                {{.Return.Var}} = {{.Return.MakeExpr}}
                for rows.Next() {
                    elem := {{.Return.MakeElemExpr}}
                    {{.Return.Var}} = append({{.Return.Var}}, elem)
                    dest := make([]interface{}, {{len .Returnings}})
                    {{- range $i, $r := .Returnings}}
                        {{- if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                            var elem{{$r.Var2}} pq.NullTime
                            dest[{{$i}}] = &elem{{$r.Var2}}
                        {{- else if .DBType.Array}}
                            dest[{{$i}}] = pq.Array(&elem.{{$r.Var}})
                        {{- else if .Complex}}
                            var elem{{.Var2}} []byte
                            dest[{{$i}}] = &elem{{$r.Var2}}
                        {{- else}}
                            dest[{{$i}}] = &elem.{{$r.Var}}
                        {{- end}}
                    {{- end}}
                    err = rows.Scan(dest...)
                    if err != nil {
                        log.Error(err)
                        return
                    }
                    {{- range $i, $r := .Returnings}}
                        {{- if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                            elem.{{$r.Var}} = elem{{$r.Var2}}.Time
                        {{- else if .DBType.Array}}
                        {{- else if .Complex}}
                            elem.{{$r.Var}} = {{$r.MakeExpr}}
                            json.Unmarshal(elem{{.Var2}}, {{$r.VarPointerExpr}}elem.{{$r.Var}})
                        {{- end}}
                    {{- end}}
                }
                if err = rows.Err(); err != nil {
                    log.Error(err)
                    return
                }
                return
            {{- /* end batch method */}}

            {{- else if eq .Kind "count"}}
                err = db.QueryRow(query, args...).Scan(&{{.Return.Var}})
                if err != nil {
                    log.Error(err)
                    log.Error(query)
                    log.Error(args...)
                }
                return
            {{- /* end count method */}}

            {{- else if eq .Kind "page"}}
                fidx := strings.LastIndex(query, " from ")
                obidx := strings.LastIndex(query, "order by")
                tQuery := `select count(*)` + query[fidx:obidx]
                dNum := strings.Count(query[obidx:], "$")
                tArgs := args[:len(args)-dNum]
                log.Debug(tQuery)
                log.Debug(tArgs...)
                err = db.QueryRow(tQuery, tArgs...).Scan(&{{(index .Results 0).Var}})
                if err != nil {
                    log.Error(err)
                    log.Error(query)
                    log.Error(args...)
                }
                if {{(index .Results 0).Var}} == 0 {
                    return
                }
                log.Debug(query)
                log.Debug(args...)
                var rows *sql.Rows
                rows, err = db.Query(query, args...)
                if err != nil {
                    log.Error(err)
                    log.Error(query)
                    log.Error(args...)
                    return
                }
                defer rows.Close()

                {{.Return.Var}} = {{.Return.MakeExpr}}
                for rows.Next() {
                    elem := {{.Return.MakeElemExpr}}
                    {{.Return.Var}} = append({{.Return.Var}}, elem)
                    dest := make([]interface{}, {{len .Returnings}})
                    {{- range $i, $r := .Returnings}}
                        {{- if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                            var elem{{$r.Var2}} pq.NullTime
                            dest[{{$i}}] = &elem{{$r.Var2}}
                        {{- else if .DBType.Array}}
                            dest[{{$i}}] = pq.Array(&elem.{{$r.Var}})
                        {{- else if .Complex}}
                            var elem{{.Var2}} []byte
                            dest[{{$i}}] = &elem{{$r.Var2}}
                        {{- else}}
                            dest[{{$i}}] = &elem.{{$r.Var}}
                        {{- end}}
                    {{- end}}
                    err = rows.Scan(dest...)
                    if err != nil {
                        log.Error(err)
                        return
                    }
                    {{- range $i, $r := .Returnings}}
                        {{- if and (eq $r.Pkg "time") (eq $r.Name "Time")}}
                            elem.{{$r.Var}} = elem{{$r.Var2}}.Time
                        {{- else if .DBType.Array}}
                        {{- else if .Complex}}
                            elem.{{$r.Var}} = {{$r.MakeExpr}}
                            json.Unmarshal(elem{{.Var2}}, {{$r.VarPointerExpr}}elem.{{$r.Var}})
                        {{- end}}
                    {{- end}}
                }
                if err = rows.Err(); err != nil {
                    log.Error(err)
                    return
                }
                return
            {{- /* end page method */}}

            {{- else}}
                {{.Kind}} template not implemented
            {{- end}}
        }
    {{- end}}{{/* end range methods */}}
{{- end}}{{/* end range interfaces */}}
